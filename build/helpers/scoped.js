"use strict";function t(t,e,i,r=void 0){for(const n of i){if("object"!=typeof e||!e)return r;if("object"==typeof n){if(!Array.isArray(e))return r;const i=Array.prototype.findIndex.call(e,t.makeConditionPredicate(n));if(-1===i)return r;e=e[i]}else{if(!Object.prototype.hasOwnProperty.call(e,n))return r;e=e[n]}}return e}function e(t,e,{initialiseValue:r,initialisePath:n=void 0!==r}={}){void 0!==r&&(e=["seq",["init",r],e]);for(let r=t.length;r-- >0;){const o=t[r];let s;if("object"==typeof o&&o)s=[],e=n?["update","all",o,e,i(o)]:["update","all",o,e];else if("number"==typeof o)s=[],e={[o]:e};else{if("string"!=typeof o)throw new Error("unsupported path type");s={},e={[o]:e}}n&&(e=["seq",["init",s],e])}return e}function i(t){if(!Array.isArray(t))return Object.fromEntries(Object.entries(t).map((([t,e])=>[t,i(e)])));if(2!==t.length||"="!==t[0])throw new Error("condition too complex");return t[1]}exports.getScopedState=t,exports.makeScopedReducer=function(i,{state:r,dispatch:n},o,{initialisePath:s=!1,initialiseValue:a}={}){return{state:t(i,r,o,a),dispatch:t=>n(e(o,t,{initialisePath:s,initialiseValue:a}))}},exports.makeScopedSpec=e;
