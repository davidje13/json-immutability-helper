function t(t,e,i,r=void 0){for(const n of i){if("object"!=typeof e||!e)return r;if("object"==typeof n){if(!Array.isArray(e))return r;const i=Array.prototype.findIndex.call(e,t.makeConditionPredicate(n));if(-1===i)return r;e=e[i]}else{if(!Object.prototype.hasOwnProperty.call(e,n))return r;e=e[n]}}return e}function e(t,e,{initialiseValue:r,initialisePath:n=void 0!==r}={}){void 0!==r&&(e=["seq",["init",r],e]);for(let r=t.length;r-- >0;){const o=t[r];let a;if("object"==typeof o&&o)a=[],e=n?["update","all",o,e,i(o)]:["update","all",o,e];else if("number"==typeof o)a=[],e={[o]:e};else{if("string"!=typeof o)throw new Error("unsupported path type");a={},e={[o]:e}}n&&(e=["seq",["init",a],e])}return e}function i(t){if(!Array.isArray(t))return Object.fromEntries(Object.entries(t).map((([t,e])=>[t,i(e)])));if(2!==t.length||"="!==t[0])throw new Error("condition too complex");return t[1]}function r(i,{state:r,dispatch:n},o,{initialisePath:a=!1,initialiseValue:f}={}){return{state:t(i,r,o,f),dispatch:t=>n(e(o,t,{initialisePath:a,initialiseValue:f}))}}export{t as getScopedState,r as makeScopedReducer,e as makeScopedSpec};
