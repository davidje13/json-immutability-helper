function t(t,e,i,r=void 0){for(const n of i){if("object"!=typeof e||!e)return r;if("object"==typeof n){if(!Array.isArray(e))return r;const i=Array.prototype.findIndex.call(e,t.makeConditionPredicate(n));if(-1===i)return r;e=e[i]}else{if(!Object.prototype.hasOwnProperty.call(e,n))return r;e=e[n]}}return e}function e(t,e,{initialiseValue:r,initialisePath:n=void 0!==r}={}){void 0!==r&&(e=["seq",["init",r],e]);for(let r=t.length;r-- >0;){const o=t[r];let f;if("object"==typeof o&&o)f=[],e=n?["updateWhere",o,e,i(o)]:["updateWhere",o,e];else if("number"==typeof o)f=[],e={[o]:e};else{if("string"!=typeof o)throw new Error("unsupported path type");f={},e={[o]:e}}n&&(e=["seq",["init",f],e])}return e}function i(t){if(!Array.isArray(t))return r(t).value;if(2===t.length&&"string"==typeof t[0])return{[t[0]]:t[1]};if(1===t.length)return r(t[0]).value;const e={};for(const i of t){const t=r(i);if(!t.keyed)return;Object.assign(e,t.value)}return e}function r(t){if("object"!=typeof t||!t||!Object.prototype.hasOwnProperty.call(t,"equals"))return;const e=Object.prototype.hasOwnProperty.call(t,"key");return{keyed:e,value:e?{[t.key]:t.equals}:t.equals}}function n(i,{state:r,dispatch:n},o,{initialisePath:f=!1,initialiseValue:u}={}){return{state:t(i,r,o,u),dispatch:t=>n(e(o,t,{initialisePath:f,initialiseValue:u}))}}export{t as getScopedState,n as makeScopedReducer,e as makeScopedSpec};
