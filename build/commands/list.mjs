import{c as r}from"../commandTypeCheck-b4O3V53M.mjs";function e(r,e,t){const n=r.length;let a,i;if(Array.isArray(e))a=e[0],i=t.makeConditionPredicate(e[1]);else{if("number"==typeof e)return e>=n||e<-n?{t:[],i:Math.sign(e)}:e<0?{t:[n+e]}:{t:[e]};a=e,i=()=>!0}const o=function(r){return"all"===r?{o:!0,l:()=>1,i:0}:("first"===r?r=0:"last"===r&&(r=-1),r<0?{o:!0,l:e=>e===-r-1?2:0,i:-1}:{o:!1,l:e=>e===r?2:0,i:1})}(a),s=[];if(o.o){for(let e=n,t=0;e-- >0;)if(i(r[e])){const r=o.l(t++);if(r&&(s.push(e),2===r))break}}else{for(let e=0,t=0;e<n;++e)if(i(r[e])){const r=o.l(t++);if(r&&(s.push(e),2===r))break}s.reverse()}return{t:s,i:o.i}}function t(r,e,t){const n=e.length;if(t.length!==n)return!1;for(let a=0;a<n;++a)if(!r.isEquals(e[a],t[a]))return!1;return!0}const n=r=>(null===r||"object"!=typeof r)&&"function"!=typeof r;var a={commands:{push:r("array","value...")(((r,e)=>e.length?[...r,...e]:r)),unshift:r("array","value...")(((r,e)=>e.length?[...e,...r]:r)),addUnique:r("array","value...")(((r,e,t)=>{t.invariant(e.every(n),"cannot add non-primitives");const a=new Set(e.filter((e=>!r.includes(e))));return a.size?[...r,...a]:r})),splice:r("array","array...")(((r,e,n)=>{let a=null;return e.forEach((e=>{n.invariant(Array.isArray(e),"expected splice parameter to be an array of arguments to splice()"),e.length&&(0!==e[1]||e.length>2)&&(a||=n.copy(r),Array.prototype.splice.apply(a,e))})),a&&!t(n,r,a)?a:r})),insert:r("array","enum[before,after]","multi-locator","value...")(((r,[t,n,...a],i)=>{const o=r.length,{t:s,i:c}=e(r,n,i);!s.length&&c&&s.push(c>0?o:-1);const l="before"===t?0:1;return i.incLoopNesting(s.length,(()=>i.update(r,["splice",...s.map((r=>[Math.max(0,Math.min(o,r+l)),0,...a]))])))})),update:r("array","multi-locator","spec","elseInit:value?")(((r,[t,n,a],i)=>{const o={},{t:s,insertStart:c}=e(r,t,i);return s.length||void 0===a||(c?(s.push(0),r=[a,...r]):(s.push(r.length),r=[...r,a])),i.incLoopNesting(s.length,(()=>{s.forEach((e=>{const t=r[e],a=i.update(t,n,{allowUnset:!0});Object.is(a,t)||(o[e]=["=",a])}))})),i.update(r,o)})),delete:r("array","multi-locator")(((r,[t],n)=>{const{t:a}=e(r,t,n);return n.update(r,["splice",...a.map((r=>[r,1]))])})),swap:r("array","single-locator","single-locator")(((r,[t,n],a)=>{const{t:i}=e(r,t,a),{t:o}=e(r,n,a);if(1!==i.length||1!==o.length)return r;const[s]=i,[c]=o,l=r[s],u=r[c];if(s===c||a.isEquals(l,u))return r;const f=[...r];return f[s]=u,f[c]=l,f})),move:r("array","multi-locator","enum[before,after]","single-locator")(((r,[n,a,i],o)=>{const{t:s}=e(r,n,o),{t:c}=e(r,i,o);if(s.reverse(),0===s.length||1!==c.length)return r;if(s.includes(c[0]))return r;const l=s.map((e=>r[e])),u=c[0]+("after"===a?1:0),f=[];for(let e=0,t=0;e<r.length;++e)e!==s[t]?(e===u&&f.push(...l),f.push(r[e])):++t;return u===r.length&&f.push(...l),t(o,r,f)?r:f}))},conditions:{length:([r],e)=>{const t=e.makeConditionPredicate(r);return r=>Array.isArray(r)&&t(r.length)},some:([r],e)=>{const t=e.makeConditionPredicate(r);return r=>Array.isArray(r)&&Array.prototype.some.call(r,t)},every:([r],e)=>{const t=e.makeConditionPredicate(r);return r=>Array.isArray(r)&&Array.prototype.every.call(r,t)},none:([r],e)=>{const t=e.makeConditionPredicate(r);return r=>Array.isArray(r)&&!Array.prototype.some.call(r,t)}}};export{a as default};
