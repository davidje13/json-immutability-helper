"use strict";var r=require("../commandTypeCheck-Dbzi5OUO.js");function e(r,e,t){const n=r.length;let i,a;if(Array.isArray(e))i=e[0],a=t.makeConditionPredicate(e[1]);else{if("number"==typeof e)return e>=n||e<-n?{t:[],i:Math.sign(e)}:e<0?{t:[n+e]}:{t:[e]};i=e,a=()=>!0}const s=function(r){return"all"===r?{o:!0,u:()=>1,i:0}:("first"===r?r=0:"last"===r&&(r=-1),r<0?{o:!0,u:e=>e===-r-1?2:0,i:-1}:{o:!1,u:e=>e===r?2:0,i:1})}(i),o=[];if(s.o){for(let e=n,t=0;e-- >0;)if(a(r[e])){const r=s.u(t++);if(r&&(o.push(e),2===r))break}}else{for(let e=0,t=0;e<n;++e)if(a(r[e])){const r=s.u(t++);if(r&&(o.push(e),2===r))break}o.reverse()}return{t:o,i:s.i}}function t(r,e,t){const n=e.length;if(t.length!==n)return!1;for(let i=0;i<n;++i)if(!r.isEquals(e[i],t[i]))return!1;return!0}const n=r=>(null===r||"object"!=typeof r)&&"function"!=typeof r;var i={commands:{push:r.config("array","value...")(((r,e)=>e.length?[...r,...e]:r)),unshift:r.config("array","value...")(((r,e)=>e.length?[...e,...r]:r)),addUnique:r.config("array","value...")(((r,e,t)=>{t.invariant(e.every(n),"cannot add non-primitives");const i=new Set(e.filter((e=>!r.includes(e))));return i.size?[...r,...i]:r})),splice:r.config("array","array...")(((r,e,n)=>{let i=null;return e.forEach((e=>{n.invariant(Array.isArray(e),"expected splice parameter to be an array of arguments to splice()"),e.length&&(0!==e[1]||e.length>2)&&(i||=n.copy(r),Array.prototype.splice.apply(i,e))})),i&&!t(n,r,i)?i:r})),insert:r.config("array","enum[before,after]","multi-locator","value...")(((r,[t,n,...i],a)=>{const s=r.length,{t:o,i:c}=e(r,n,a);!o.length&&c&&o.push(c>0?s:-1);const u="before"===t?0:1;return a.incLoopNesting(o.length,(()=>a.update(r,["splice",...o.map((r=>[Math.max(0,Math.min(s,r+u)),0,...i]))])))})),update:r.config("array","multi-locator","spec","elseInit:value?")(((r,[t,n,i],a)=>{const s={},{t:o,insertStart:c}=e(r,t,a);return o.length||void 0===i||(c?(o.push(0),r=[i,...r]):(o.push(r.length),r=[...r,i])),a.incLoopNesting(o.length,(()=>{o.forEach((e=>{const t=r[e],i=a.update(t,n,{allowUnset:!0});Object.is(i,t)||(s[e]=["=",i])}))})),a.update(r,s)})),delete:r.config("array","multi-locator")(((r,[t],n)=>{const{t:i}=e(r,t,n);return n.update(r,["splice",...i.map((r=>[r,1]))])})),swap:r.config("array","single-locator","single-locator")(((r,[t,n],i)=>{const{t:a}=e(r,t,i),{t:s}=e(r,n,i);if(1!==a.length||1!==s.length)return r;const[o]=a,[c]=s,u=r[o],l=r[c];if(o===c||i.isEquals(u,l))return r;const f=[...r];return f[o]=l,f[c]=u,f})),move:r.config("array","multi-locator","enum[before,after]","single-locator")(((r,[n,i,a],s)=>{const{t:o}=e(r,n,s),{t:c}=e(r,a,s);if(o.reverse(),0===o.length||1!==c.length)return r;if(o.includes(c[0]))return r;const u=o.map((e=>r[e])),l=c[0]+("after"===i?1:0),f=[];for(let e=0,t=0;e<r.length;++e)e!==o[t]?(e===l&&f.push(...u),f.push(r[e])):++t;return l===r.length&&f.push(...u),t(s,r,f)?r:f}))},conditions:{length:([r],e)=>{const t=e.makeConditionPredicate(r);return r=>Array.isArray(r)&&t(r.length)},some:([r],e)=>{const t=e.makeConditionPredicate(r);return r=>Array.isArray(r)&&Array.prototype.some.call(r,t)},every:([r],e)=>{const t=e.makeConditionPredicate(r);return r=>Array.isArray(r)&&Array.prototype.every.call(r,t)},none:([r],e)=>{const t=e.makeConditionPredicate(r);return r=>Array.isArray(r)&&!Array.prototype.some.call(r,t)}}};module.exports=i;
