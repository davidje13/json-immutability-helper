"use strict";var t=require("./commandTypeCheck-Dbzi5OUO.js");const e={"=":t.config("*","value")(((t,[e])=>e)),unset:t.config("*")(((t,e,n)=>n.UNSET_TOKEN)),init:t.config("*","value")(((t,[e])=>void 0===t?e:t)),if:t.config("*","condition","spec","spec?")(((t,[e,n,o=null],i)=>i.makeConditionPredicate(e)(t)?i.update(t,n,{allowUnset:!0}):o?i.update(t,o,{allowUnset:!0}):t)),seq:t.config("*","spec...")(((t,e,n)=>e.reduce(((t,e)=>n.update(t,e,{allowUnset:!0})),t))),"~":t.config("boolean")((t=>!t)),merge:t.config("object?","merge:object","initial:object?")(((t,[e,n],o)=>{const i=void 0===t?n:t;return o.applyMerge(i,Object.entries(e).filter((([,t])=>void 0!==t)))})),"+":t.config("number","number")(((t,[e])=>t+e)),"-":t.config("number","number")(((t,[e])=>t-e))};var n={commands:e};const o={and:(t,e)=>{const n=t.map((t=>e.makeConditionPredicate(t)));return t=>n.every((e=>e(t)))},or:(t,e)=>{const n=t.map((t=>e.makeConditionPredicate(t)));return t=>n.some((e=>e(t)))},not:([t],e)=>{const n=e.makeConditionPredicate(t);return t=>!n(t)},exists:()=>t=>void 0!==t,"=":t=>e=>t.includes(e),"!=":t=>e=>!t.includes(e),"~=":t=>e=>t.some((t=>t==e)),"!~=":t=>e=>!t.some((t=>t==e)),">":([t])=>e=>e>t,">=":([t])=>e=>e>=t,"<":([t])=>e=>e<t,"<=":([t])=>e=>e<=t};var i={conditions:o};function s(t,e){if(!t){const t="function"==typeof e?e():e||"bad input";throw new Error(t)}}const r=(t,e)=>Object.prototype.hasOwnProperty.call(t,e)?t[e]:void 0,c=(t,e,n)=>Object.defineProperty(t,e,{value:n,configurable:!0,enumerable:!0,writable:!0}),a=Array.isArray;function u(t){return a(t)&&"seq"===t[0]?t.slice(1):[t]}function h(t,e){if(a(t)||a(e))return["seq",...u(t),...u(e)];const n=Object.assign({},t);return Object.entries(e).forEach((([t,e])=>{Object.prototype.hasOwnProperty.call(n,t)?n[t]=h(n[t],e):void 0===n[t]?n[t]=e:c(n,t,e)})),n}const b=Symbol("unset");class l{constructor(t){var e;Object.assign(this,t,{commands:new Map(t.commands),conditions:new Map(t.conditions),t:0,o:1,UNSET_TOKEN:b,invariant:s}),e=this,["with","update","applyMerge","combine","makeConditionPredicate"].forEach((t=>{e[t]=e[t].bind(e)})),Object.assign(this.update,{context:this,combine:this.combine,UNSET_TOKEN:this.UNSET_TOKEN,with:(...t)=>this.with(...t).update})}with(...t){const e={commands:[...this.commands.entries()],conditions:[...this.conditions.entries()],limits:Object.assign({},this.limits),rpnOperators:Object.assign({},this.rpnOperators),rpnConstants:Object.assign({},this.rpnConstants),isEquals:this.isEquals,copy:this.copy};return new l(t.reduce(((t,e)=>Object.assign(t,e,{commands:[...t.commands,...Object.entries(e.commands||{})],conditions:[...t.conditions,...Object.entries(e.conditions||{})],limits:Object.assign(t.limits,e.limits),rpnOperators:Object.assign(t.rpnOperators,e.rpnOperators),rpnConstants:Object.assign(t.rpnConstants,e.rpnConstants)})),e))}update(t,e,{path:n="",allowUnset:o=!1}={}){const i=t===b?void 0:t;if(a(e)){const[t,...r]=e,c=this.commands.get(t);try{s(c,"unknown command");const t=c(i,r,this);return t===b?o?b:void 0:this.isEquals(t,i)?i:t}catch(e){throw new Error(`/${n} ${t}: ${e.message}`)}}s("object"==typeof t&&null!==t,`/${n}: target must be an object or array`),s("object"==typeof e&&null!==e,`/${n}: spec must be an object or a command`);const c=n?`${n}/`:"",u=Object.entries(e).map((([t,e])=>[t,this.update(r(i,t),e,{path:`${c}${t}`,allowUnset:!0})]));return this.applyMerge(i,u,n)}applyMerge(t,e,n=""){let o=null;const i=[],s=Array.isArray(t);return e.forEach((([e,r])=>{if(s&&!((t,e)=>{const n=Number(t);return n>=0&&n<e&&n.toFixed(0)===t})(e,t.length))throw new Error(`/${n}: cannot modify array property ${e}`);const a=r!==b,u=Object.prototype.hasOwnProperty.call(t,e);(a!==u||a&&!this.isEquals(t[e],r))&&(o=o||this.copy(t),a?u||void 0===t[e]?o[e]=r:c(o,e,r):s?i.push(Number(e)):delete o[e])})),i.length>0&&function(t,e){e.sort(((t,e)=>t-e));let n=1;for(let o=e[0]+1;o<t.length;++o)o===e[n]?++n:t[o-n]=t[o];t.length-=n}(o,i),o||t}combine(t,e){return s(!e,"combine(): must provide a single (list) parameter."),t.reduce(h,{})}makeConditionPredicate(t){if(s("object"==typeof t&&t,"invalid condition"),Array.isArray(t)){const[e,...n]=t,o=this.conditions.get(e);return s(o,`unknown condition type: ${e}`),o(n,this)}const e=Object.entries(t).map((([t,e])=>{const n=this.makeConditionPredicate(e);return e=>n("object"==typeof e&&e?r(e,t):void 0)}));return t=>e.every((e=>e(t)))}incLoopNesting(t,e){if(t<=1)return e();const n=this.o;++this.t,this.o*=t;try{return s(this.t<this.limits.recursionDepth&&this.o<this.limits.recursionBreadth,`too much recursion: ${this.t} deep, ~${this.o} items`),e()}finally{--this.t,this.o=n}}}const m={commands:[],conditions:[],limits:{stringLength:10240,recursionDepth:10,recursionBreadth:1e5},rpnOperators:{},rpnConstants:{},isEquals:Object.is,copy:t=>Array.isArray(t)?[...t]:"object"==typeof t&&t?Object.assign({},t):t},d=new l(m).with(n,i);d.combine,d.update,d.context=d,d.default=d,module.exports=d;
