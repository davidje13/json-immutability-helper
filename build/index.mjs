import{c as t}from"./commandTypeCheck-b4O3V53M.mjs";const e={set:t("*","value")(((t,[e])=>e)),unset:t("*")(((t,e,n)=>n.UNSET_TOKEN)),init:t("*","value")(((t,[e])=>void 0===t?e:t)),updateIf:t("*","condition","spec","spec?")(((t,[e,n,o=null],s)=>s.makeConditionPredicate(e)(t)?s.update(t,n,{allowUnset:!0}):o?s.update(t,o,{allowUnset:!0}):t)),seq:t("*","spec...")(((t,e,n)=>e.reduce(((t,e)=>n.update(t,e,{allowUnset:!0})),t))),toggle:t("boolean")((t=>!t)),merge:t("object?","merge:object","initial:object?")(((t,[e,n],o)=>{const s=void 0===t?n:t;return o.applyMerge(s,Object.entries(e))})),add:t("number","number")(((t,[e])=>t+e)),subtract:t("number","number")(((t,[e])=>t-e))};e.if=e.updateIf,e["="]=e.set,e["+"]=e.add,e["-"]=e.subtract,e["~"]=e.toggle;var n={commands:e};var o={conditions:{equals:t=>e=>e===t,not:t=>e=>e!==t,greaterThan:t=>e=>e>t,lessThan:t=>e=>e<t,greaterThanOrEqual:t=>e=>e>=t,lessThanOrEqual:t=>e=>e<=t,notNullish:()=>t=>null!=t}};function s(t,e){if(!t){const t="function"==typeof e?e():e||"bad input";throw new Error(t)}}const i=(t,e)=>Object.prototype.hasOwnProperty.call(t,e)?t[e]:void 0,r=(t,e,n)=>Object.defineProperty(t,e,{value:n,configurable:!0,enumerable:!0,writable:!0}),c=Array.isArray;function a(t){return c(t)&&"seq"===t[0]?t.slice(1):[t]}function u(t,e){if(c(t)||c(e))return["seq",...a(t),...a(e)];const n=Object.assign({},t);return Object.entries(e).forEach((([t,e])=>{Object.prototype.hasOwnProperty.call(n,t)?n[t]=u(n[t],e):void 0===n[t]?n[t]=e:r(n,t,e)})),n}function h(t,e){s("object"==typeof t,`expected spec of condition to be an object; got ${t}`);const n=Object.entries(t).filter((([t])=>"key"!==t)).map((([t,n])=>{const o=e.conditions.get(t);return s(o,`unknown condition type: ${t}`),o(n,e)}));return void 0===t.key?(s(n.length>0,"invalid condition"),t=>n.every((e=>e(t)))):(n.length||n.push(o.conditions.notNullish()),e=>{const o=i(e,t.key);return n.every((t=>t(o)))})}const l=Symbol("unset");class b{constructor(t){var e;Object.assign(this,t,{commands:new Map(t.commands),conditions:new Map(t.conditions),t:0,o:1,UNSET_TOKEN:l,invariant:s}),e=this,["with","update","applyMerge","combine","makeConditionPredicate"].forEach((t=>{e[t]=e[t].bind(e)})),Object.assign(this.update,{context:this,combine:this.combine,UNSET_TOKEN:this.UNSET_TOKEN,with:(...t)=>this.with(...t).update})}with(...t){const e={commands:[...this.commands.entries()],conditions:[...this.conditions.entries()],limits:Object.assign({},this.limits),rpnOperators:Object.assign({},this.rpnOperators),rpnConstants:Object.assign({},this.rpnConstants),isEquals:this.isEquals,copy:this.copy};return new b(t.reduce(((t,e)=>Object.assign(t,e,{commands:[...t.commands,...Object.entries(e.commands||{})],conditions:[...t.conditions,...Object.entries(e.conditions||{})],limits:Object.assign(t.limits,e.limits),rpnOperators:Object.assign(t.rpnOperators,e.rpnOperators),rpnConstants:Object.assign(t.rpnConstants,e.rpnConstants)})),e))}update(t,e,{path:n="",allowUnset:o=!1}={}){const r=t===l?void 0:t;if(c(e)){const[t,...i]=e,c=this.commands.get(t);try{s(c,"unknown command");const t=c(r,i,this);return t===l?o?l:void 0:this.isEquals(t,r)?r:t}catch(e){throw new Error(`/${n} ${t}: ${e.message}`)}}s("object"==typeof t&&null!==t,`/${n}: target must be an object or array`),s("object"==typeof e&&null!==e,`/${n}: spec must be an object or a command`);const a=n?`${n}/`:"",u=Object.entries(e).map((([t,e])=>[t,this.update(i(r,t),e,{path:`${a}${t}`,allowUnset:!0})]));return this.applyMerge(r,u,n)}applyMerge(t,e,n=""){let o=null;const s=[],i=Array.isArray(t);return e.forEach((([e,c])=>{if(i&&!((t,e)=>{const n=Number(t);return n>=0&&n<e&&n.toFixed(0)===t})(e,t.length))throw new Error(`/${n}: cannot modify array property ${e}`);const a=c!==l,u=Object.prototype.hasOwnProperty.call(t,e);(a!==u||a&&!this.isEquals(t[e],c))&&(o=o||this.copy(t),a?u||void 0===t[e]?o[e]=c:r(o,e,c):i?s.push(Number(e)):delete o[e])})),s.length>0&&function(t,e){e.sort(((t,e)=>t-e));let n=1;for(let o=e[0]+1;o<t.length;++o)o===e[n]?++n:t[o-n]=t[o];t.length-=n}(o,s),o||t}combine(t,e){return s(!e,"combine(): must provide a single (list) parameter."),t.reduce(u,{})}makeConditionPredicate(t){if(!Array.isArray(t))return h(t,this);if(s(t.length>0,"update(): empty condition."),"string"==typeof t[0]&&2===t.length)return h({key:t[0],equals:t[1]},this);const e=t.map((t=>h(t,this)));return t=>e.every((e=>e(t)))}incLoopNesting(t,e){if(t<=1)return e();const n=this.o;++this.t,this.o*=t;try{return s(this.t<this.limits.recursionDepth&&this.o<this.limits.recursionBreadth,`too much recursion: ${this.t} deep, ~${this.o} items`),e()}finally{--this.t,this.o=n}}}const p={commands:[],conditions:[],limits:{stringLength:10240,recursionDepth:10,recursionBreadth:1e5},rpnOperators:{},rpnConstants:{},isEquals:Object.is,copy:t=>Array.isArray(t)?[...t]:"object"==typeof t&&t?Object.assign({},t):t},d=new b(p).with(n,o),m=d.combine,j=d.update;export{l as UNSET_TOKEN,m as combine,d as context,d as default,s as invariant,j as update};
