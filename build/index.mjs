import{c as t}from"./commandTypeCheck-b4O3V53M.mjs";const n={"=":t("*","value")(((t,[n])=>n)),unset:t("*")(((t,n,e)=>e.UNSET_TOKEN)),init:t("*","value")(((t,[n])=>void 0===t?n:t)),if:t("*","condition","spec","spec?")(((t,[n,e,o=null],s)=>s.makeConditionPredicate(n)(t)?s.update(t,e,{allowUnset:!0}):o?s.update(t,o,{allowUnset:!0}):t)),seq:t("*","spec...")(((t,n,e)=>n.reduce(((t,n)=>e.update(t,n,{allowUnset:!0})),t))),"~":t("boolean")((t=>!t)),merge:t("object?","merge:object","initial:object?")(((t,[n,e],o)=>{const s=void 0===t?e:t;return o.applyMerge(s,Object.entries(n).filter((([,t])=>void 0!==t)))})),"+":t("number","number")(((t,[n])=>t+n)),"-":t("number","number")(((t,[n])=>t-n))};var e={commands:n};const o={and:(t,n)=>{const e=t.map((t=>n.makeConditionPredicate(t)));return t=>e.every((n=>n(t)))},or:(t,n)=>{const e=t.map((t=>n.makeConditionPredicate(t)));return t=>e.some((n=>n(t)))},not:([t],n)=>{const e=n.makeConditionPredicate(t);return t=>!e(t)},exists:()=>t=>void 0!==t,"=":t=>n=>t.includes(n),"!=":t=>n=>!t.includes(n),"~=":t=>n=>t.some((t=>t==n)),"!~=":t=>n=>!t.some((t=>t==n)),">":([t])=>n=>n>t,">=":([t])=>n=>n>=t,"<":([t])=>n=>n<t,"<=":([t])=>n=>n<=t};var s={conditions:o};function i(t,n){if(!t){const t="function"==typeof n?n():n||"bad input";throw new Error(t)}}const r=(t,n)=>Object.prototype.hasOwnProperty.call(t,n)?t[n]:void 0,c=(t,n,e)=>Object.defineProperty(t,n,{value:e,configurable:!0,enumerable:!0,writable:!0}),a=Array.isArray;function u(t){return a(t)&&"seq"===t[0]?t.slice(1):[t]}function h(t,n){if(a(t)||a(n)){const e=u(t),o=u(n);if(e.length&&o.length&&e.length+o.length>2){const t=e.pop(),n=o.shift();return["seq",...e,...u(h(t,n)),...o]}return["seq",...e,...o]}const e={...t};return Object.entries(n).forEach((([t,n])=>{Object.prototype.hasOwnProperty.call(e,t)?e[t]=h(e[t],n):void 0===e[t]?e[t]=n:c(e,t,n)})),e}const b=Symbol("unset");class l{constructor(t){var n;Object.assign(this,t,{commands:new Map(t.commands),conditions:new Map(t.conditions),t:0,o:1,UNSET_TOKEN:b,invariant:i}),n=this,["with","update","applyMerge","combine","makeConditionPredicate"].forEach((t=>{n[t]=n[t].bind(n)})),Object.assign(this.update,{context:this,combine:this.combine,UNSET_TOKEN:this.UNSET_TOKEN,with:(...t)=>this.with(...t).update})}with(...t){const n={commands:[...this.commands.entries()],conditions:[...this.conditions.entries()],limits:{...this.limits},rpnOperators:{...this.rpnOperators},rpnConstants:{...this.rpnConstants},isEquals:this.isEquals,copy:this.copy};return new l(t.reduce(((t,n)=>Object.assign(t,n,{commands:[...t.commands,...Object.entries(n.commands||{})],conditions:[...t.conditions,...Object.entries(n.conditions||{})],limits:Object.assign(t.limits,n.limits),rpnOperators:Object.assign(t.rpnOperators,n.rpnOperators),rpnConstants:Object.assign(t.rpnConstants,n.rpnConstants)})),n))}update(t,n,{path:e="",allowUnset:o=!1}={}){const s=t===b?void 0:t;if(a(n)){const[t,...r]=n,c=this.commands.get(t);try{i(c,"unknown command");const t=c(s,r,this);return t===b?o?b:void 0:this.isEquals(t,s)?s:t}catch(n){throw new Error(`/${e} ${t}: ${n.message}`)}}i("object"==typeof t&&null!==t,`/${e}: target must be an object or array`),i("object"==typeof n&&null!==n,`/${e}: spec must be an object or a command`);const c=e?`${e}/`:"",u=Object.entries(n).map((([t,n])=>[t,this.update(r(s,t),n,{path:`${c}${t}`,allowUnset:!0})]));return this.applyMerge(s,u,e)}applyMerge(t,n,e=""){let o=null;const s=[],i=Array.isArray(t);return n.forEach((([n,r])=>{if(i&&!((t,n)=>{const e=Number(t);return e>=0&&e<n&&e.toFixed(0)===t})(n,t.length))throw new Error(`/${e}: cannot modify array property ${n}`);const a=r!==b,u=Object.prototype.hasOwnProperty.call(t,n);(a!==u||a&&!this.isEquals(t[n],r))&&(o=o||this.copy(t),a?u||void 0===t[n]?o[n]=r:c(o,n,r):i?s.push(Number(n)):delete o[n])})),s.length>0&&function(t,n){n.sort(((t,n)=>t-n));let e=1;for(let o=n[0]+1;o<t.length;++o)o===n[e]?++e:t[o-e]=t[o];t.length-=e}(o,s),o||t}combine(t,n){return i(!n,"combine(): must provide a single (list) parameter."),t.length>0?t.reduce(h):{}}makeConditionPredicate(t){if(i("object"==typeof t&&t,"invalid condition"),Array.isArray(t)){const[n,...e]=t,o=this.conditions.get(n);return i(o,`unknown condition type: ${n}`),o(e,this)}const n=Object.entries(t).map((([t,n])=>{const e=this.makeConditionPredicate(n);return n=>e("object"==typeof n&&n?r(n,t):void 0)}));return t=>n.every((n=>n(t)))}incLoopNesting(t,n){if(t<=1)return n();const e=this.o;++this.t,this.o*=t;try{return i(this.t<this.limits.recursionDepth&&this.o<this.limits.recursionBreadth,`too much recursion: ${this.t} deep, ~${this.o} items`),n()}finally{--this.t,this.o=e}}}const m={commands:[],conditions:[],limits:{stringLength:10240,recursionDepth:10,recursionBreadth:1e5},rpnOperators:{},rpnConstants:{},isEquals:Object.is,copy:t=>Array.isArray(t)?[...t]:"object"==typeof t&&t?{...t}:t},p=new l(m).with(e,s),d=p.combine,j=p.update;export{b as UNSET_TOKEN,d as combine,p as context,p as default,i as invariant,j as update};
